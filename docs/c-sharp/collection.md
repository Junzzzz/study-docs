# 常用集合类

## List<T\>

`List` 类是一个泛型集合类，事实上就是一个可变数组，非线程安全。

当添加的元素超过数组容量时会进行扩容，重新分配一个新的内存空间，并将原有的数据复制到新的内存里，这时候添加操作的时间复杂度 $O(1)$ 会退化成 $O(n)$。

### 注意点

1. 相较于 `ArrayList` ， `List<T>` 在大多数情况表现更好，同时由于泛型的类型约束，不容易出错。此外，可以避免值类型和引用类型之间的转换（拆、装箱）。
2. `T` 类型需要实现 `IEquatable<T>` 接口，否则像 `Contains` 方法需要将元素装箱然后调用 `Objects.Equals(Object)` 方法才能进行比较。
3. List类是无序集合，在使用 `BinarySearch` 方法前需要调用 `Sort` 方法进行排序或者在二分查找参数里传入 `IComparer<T>` 比较器。

## ArrayList

相当于 `List<Object>` ，是非泛型集合类，历史遗留产物，官方不推荐使用[^1]

## Dictionary

主要用于存放键值对，通过键(Key)来查找值(Value)。速度很快，一般情况下时间复杂度很接近 $O(1)$

### 注意点

前面也写到了是 **一般情况** 查找速度才会很快，当然也会出现极端情况。由于存放数据是通过计算键的Hash散列值来得到存放位置的，难免会出现重复的情况（碰撞）。出现碰撞的概率取决于定义的 `HashCode` 函数以及字典的容量大小。

1. `GetHashCode` 函数产生的整数需要尽可能分散，当然大多数情况不需要考虑这个问题。
2. 在可以得知大致存放数据容量大小的情况下，在实例化 `Dictionary` 对象时最好填写初始容量，避免因为不断添加数据使得存放数组扩容而导致的性能损耗。
3. 存放在其中的键对象属性不能改变（主要是会影响哈希值的属性），否则可能会无法检索到对应的值。


!!! tip "Hash"

    哈希值代表了一个对象的特征值，两个不同的对象可能会产生相同的特征值。


## Hashtable

相当于没有泛型的 `Dictionary` 类型，同样官方不推荐使用[^1]

## Stack

堆栈，经典类型。数据就像物品一样堆叠存放，只能在一个堆的顶端进行存取，最后放上来的东西会被优先取出。

这种数据结构有多种实现方式，比如数组或者链表，C#中采用数组来存放数据，因此会存在数组扩容问题，超出预设容量会导致添加数据的时间复杂度增加到 $O(n)$ ，因此使用时建议最好预设初始容量。

## Queue

队列，经典类型。顾名思义，排在队伍前面的优先，即先存放的数据先被取出。

在C#中采用循环数组的方式实现，同样存在扩容问题，注意预设容量。

!!! tip "注意"

    1. 使用 `Stack` 和 `Queue` 时注意选择有泛型的类，即 `System.Collections.Generic` 命名域下的类，因为 **存在同名** 没有泛型的历史遗留产物。
    2. 可以使用 `TrimExcess()` 方法裁剪多余容量，减小内存消耗。（只在小于90%的情况下有效）

[^1]: 官方说明：[DE0006: Non-generic collections shouldn't be used](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md)
